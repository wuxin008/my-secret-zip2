#version 450
#extension GL_ARB_shading_language_include : require
#include "simulation_header.glsl"

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

void main() 
{
    uvec3 globalSize = gl_NumWorkGroups * gl_WorkGroupSize;
    uint index = gl_GlobalInvocationID.z * globalSize.x * globalSize.y + gl_GlobalInvocationID.y * globalSize.x + gl_GlobalInvocationID.x;
    if (index >= ubo.Nxyz) return;
    
    uint flagsn = flags[index]; // cache flags[n] for multiple readings
	uint flagsn_bo=flagsn&TYPE_BO, flagsn_su=flagsn&TYPE_SU; // extract boundary and surface flags
	if(flagsn_bo==TYPE_S||flagsn_su==TYPE_G) return; // if cell is solid boundary or gas, just return
    
    uint nbs[Q];
    neighbors(index, nbs);
    
    float fhn[Q];
    load_f(index, fhn, nbs, ubo.t); // perform streaming (part 2);

#ifdef SURFACE
	float fon[Q]; // outgoing DDFs
	fon[0] = fhn[0]; // fon[0] is already loaded in fhn[0]
	load_f_outgoing(index, fon, nbs, ubo.t); // load outgoing DDFs

	float massn = masses[index];
	for(uint q=1u; q<Q; q++) {
		massn += massexes[nbs[q]]; // distribute excess mass from last step which is stored in neighbors
	}
	if(flagsn_su==TYPE_F) { // cell is fluid
		for(uint q = 1; q < Q; q+=2) {
			massn += fhn[q] - fon[q];
			massn += fhn[q+1] - fon[q+1];
		}
	} else if(flagsn_su==TYPE_I) { // cell is interface
		float phij[Q]; // cache fill level of neighbor lattice points
		for(uint q=1u; q<Q; q++) phij[q] = phis[nbs[q]]; // cache fill level of neighbor lattice points
		float rhon, uxn, uyn, uzn, rho_laplace=0.0f; // no surface tension if rho_laplace is not overwritten later
#ifndef EQUILIBRIUM_BOUNDARIES
		calculate_rho_u(fon, rhon, uxn, uyn, uzn); // calculate density and velocity fields from fon (not fhn)
#else // EQUILIBRIUM_BOUNDARIES
		if(flagsn_bo==TYPE_E) {
			load_macro(index, rhon, uxn, uyn);
			//rhon = rhos[            index]; // apply preset velocity/density
			//uxn  = vels[            index];
			//uyn  = vels[   ubo.Nxyz+index];
			//uzn  = vels[2u*ubo.Nxyz+index];
		} else {
			calculate_rho_u(fon, rhon, uxn, uyn, uzn); // calculate density and velocity fields from fon (not fhn)
		}
#endif // EQUILIBRIUM_BOUNDARIES
		uxn = clamp(uxn, -def_c, def_c); // limit velocity (for stability purposes)
		uyn = clamp(uyn, -def_c, def_c);
		uzn = clamp(uzn, -def_c, def_c);
		phij[0] = calculate_phi(rhon, massn, flagsn); // don't load phi[n] from memory, instead recalculate it with mass corrected by excess mass
		rho_laplace = ubo.sigma==0.0f ? 0.0f : ubo.sigma*calculate_curvature(index, phij); // surface tension least squares fit (PLIC, most accurate)
		float feg[Q]; // reconstruct f from neighbor gas lattice points
		const float rho2tmp = 0.5f/rhon; // apply external volume force (Guo forcing, Krueger p.233f)
		const float uxntmp = clamp(fma(ubo.fx, rho2tmp, uxn), -def_c, def_c); // limit velocity (for stability purposes)
		const float uyntmp = clamp(fma(ubo.fy, rho2tmp, uyn), -def_c, def_c); // force term: F*dt/(2*rho)
		const float uzntmp = clamp(fma(ubo.fz, rho2tmp, uzn), -def_c, def_c);
		calculate_f_eq(1.0f-rho_laplace, uxntmp, uyntmp, uzntmp, feg); // calculate gas equilibrium DDFs with constant ambient pressure
		uint flagsj_su[Q]; // cache neighbor flags for multiple readings
		for(uint q=1u; q<Q; q++) flagsj_su[q] = flags[nbs[q]]&TYPE_SU;
		for(uint q=1u; q<Q; q+=2u) { // calculate mass exchange between current cell and fluid/interface cells
			massn += (flagsj_su[q   ]&(TYPE_F|TYPE_I))!=0 ? flagsj_su[q   ]==TYPE_F ? fhn[q+1]-fon[q   ] : 0.5f*(phij[q   ]+phij[0])*(fhn[q+1u]-fon[q   ]) : 0.0f; // neighbor is fluid or interface cell
			massn += (flagsj_su[q+1u]&(TYPE_F|TYPE_I))!=0 ? flagsj_su[q+1u]==TYPE_F ? fhn[q  ]-fon[q+1u] : 0.5f*(phij[q+1u]+phij[0])*(fhn[q   ]-fon[q+1u]) : 0.0f; // fluid : interface : gas
		}
		for(uint q=1u; q<Q; q+=2u) { // calculate and store reconstructed gas DDFs
			if (flagsj_su[q+1]==TYPE_G) fhn[q   ] = feg[q+1u]-fon[q+1u]+feg[q   ];
			if (flagsj_su[q  ]==TYPE_G) fhn[q+1u] = feg[q   ]-fon[q   ]+feg[q+1u];
		}
	}

	masses[index] = massn;
#endif

#ifdef MOVING_BOUNDARIES
    if ((flagsn & TYPE_MS) == TYPE_MS) { // MOVING_BOUNDARIES
        apply_moving_boundaries(fhn, nbs); // apply Dirichlet velocity boundaries if necessary (reads velocities of only neighboring boundary cells, which do not change during simulation)
	}
#endif
    
    float rhon, uxn, uyn, uzn; // calculate local density and velocity for collision
#ifndef EQUILIBRIUM_BOUNDARIES
    calculate_rho_u(fhn, rhon, uxn, uyn, uzn); // calculate density and velocity fields from fi
#else
	if(flagsn_bo==TYPE_E) {
		load_macro(index, rhon, uxn, uyn, uzn);
		//rhon = rhos[            index]; // apply preset velocity/density
		//uxn  = vels[            index];
		//uyn  = vels[   ubo.Nxyz+index];
		//uzn  = vels[2u*ubo.Nxyz+index];
	} else {
		calculate_rho_u(fhn, rhon, uxn, uyn, uzn); // calculate density and velocity fields from fi
	}
#endif
    float fxn=ubo.fx, fyn=ubo.fy, fzn=ubo.fz; // force starts as constant volume force, can be modified before call of calculate_forcing_terms(...)
    float Fin[Q]; // forcing terms
    
#ifdef FORCE_FIELD // FORCE_FIELD
    { // separate block to avoid variable name conflicts
		fxn += cfs[            index]; // apply force field
		fyn += cfs[   ubo.Nxyz+index];
		fzn += cfs[2u*ubo.Nxyz+index];
	}
#endif

#ifdef SURFACE
	if(flagsn_su==TYPE_I) { // cell was interface, eventually initiate flag change
		bool TYPE_NO_F=true, TYPE_NO_G=true; // temporary flags for no fluid or gas neighbors
		for(uint q=1u; q<Q; q++) {
			const uint flagsji_su = flags[nbs[q]]&TYPE_SU; // extract SURFACE flags
			TYPE_NO_F = TYPE_NO_F&&flagsji_su!=TYPE_F;
			TYPE_NO_G = TYPE_NO_G&&flagsji_su!=TYPE_G;
		}
		// const float massn = masses[index]; // load mass
		if(massn>rhon || TYPE_NO_G)      flags[index] = (flagsn&~TYPE_SU)|TYPE_IF; // set flag interface->fluid
		else if(massn<0.0f || TYPE_NO_F) flags[index] = (flagsn&~TYPE_SU)|TYPE_IG; // set flag interface->gas
	}
#endif

    {
#ifdef VOLUME_FORCE    // VOLUME_FORCE
        const float rho2 = 0.5f/rhon; // apply external volume force (Guo forcing, Krueger p.233f)
		uxn = clamp(fma(fxn, rho2, uxn), -def_c, def_c); // limit velocity (for stability purposes)
		uyn = clamp(fma(fyn, rho2, uyn), -def_c, def_c); // force term: F*dt/(2*rho)
		uzn = clamp(fma(fzn, rho2, uzn), -def_c, def_c);
		calculate_forcing_terms(uxn, uyn, uzn, fxn, fyn, fzn, Fin); // calculate volume force terms Fin from velocity field (Guo forcing, Krueger p.233f)
#else
		uxn = clamp(uxn, -def_c, def_c); // limit velocity (for stability purposes)
		uyn = clamp(uyn, -def_c, def_c); // force term: F*dt/(2*rho)
		uzn = clamp(uzn, -def_c, def_c);
		for(uint q=0u; q<Q; q++) Fin[q] = 0.0f;
#endif
    }

#ifndef EQUILIBRIUM_BOUNDARIES
#ifdef UPDATE_FIELDS
	store_macro(index, rhon, uxn, uyn, uzn);
    //rhos[            index] = float16_t(rhon); // update density field
    //vels[            index] = float16_t(uxn); // update velocity field
    //vels[   ubo.Nxyz+index] = float16_t(uyn);
    //vels[2u*ubo.Nxyz+index] = float16_t(uzn);
#endif
#else
#ifdef UPDATE_FIELDS
	if(flagsn_bo!=TYPE_E) { // only update fields for non-TYPE_E cells
		store_macro(index, rhon, uxn, uyn, uzn);
		//rhos[            index] = float16_t(rhon); // update density field
		//vels[            index] = float16_t(uxn); // update velocity field
		//vels[   ubo.Nxyz+index] = float16_t(uyn);
		//vels[2u*ubo.Nxyz+index] = float16_t(uzn);
	}
#endif
#endif
    
    float feq[Q]; // equilibrium DDFs
    calculate_f_eq(rhon, uxn, uyn, uzn, feq); // calculate equilibrium DDFs
    float w = ubo.inv_tau; // LBM relaxation rate w = dt/tau = dt/(nu/c^2+dt/2) = 1/(3*nu+1/2)

#ifdef SUBGRID
    // SUBGRID
	{ // Smagorinsky-Lilly subgrid turbulence model, source: https://arxiv.org/pdf/comp-gas/9401004.pdf, in the eq. below (26), it is "tau_0" not "nu_0", and "sqrt(2)/rho" (they call "rho" "n") is missing
		const float tau0 = 1.0f/w; // source 2: https://youtu.be/V8ydRrdCzl0
		float Hxx=0.0f, Hyy=0.0f, Hzz=0.0f, Hxy=0.0f, Hxz=0.0f, Hyz=0.0f; // non-equilibrium stress tensor
		for(uint q=1u; q<Q; q++) {
			const float fneqi = fhn[q]-feq[q];
			const float cxi=c(q), cyi=c(Q+q), czi=c(2u*Q+q);
			Hxx += cxi*cxi*fneqi; //Hyx += cyi*cxi*fneqi; Hzx += czi*cxi*fneqi; // symmetric tensor
			Hxy += cxi*cyi*fneqi; Hyy += cyi*cyi*fneqi; //Hzy += czi*cyi*fneqi;
			Hxz += cxi*czi*fneqi; Hyz += cyi*czi*fneqi; Hzz += czi*czi*fneqi;
		}
		const float Q0 = sq(Hxx)+sq(Hyy)+sq(Hzz)+2.0f*(sq(Hxy)+sq(Hxz)+sq(Hyz)); // Q = H*H, turbulent eddy viscosity nut = (C*Delta)^2*|S|, intensity of local strain rate tensor |S|=sqrt(2*S*S)
		w = 2.0f/(tau0+sqrt(sq(tau0)+0.76421222f*sqrt(Q0)/rhon)); // 0.76421222 = 18*sqrt(2)*(C*Delta)^2, C = 1/pi*(2/(3*CK))^(3/4) = Smagorinsky-Lilly constant, CK = 3/2 = Kolmogorov constant, Delta = 1 = lattice constant
	} // modity LBM relaxation rate by increasing effective viscosity in regions of high strain rate (add turbulent eddy viscosity), nu_eff = nu_0+nu_t
#endif// SUBGRID

#if defined(SRT)
#ifdef VOLUME_FORCE
    const float c_tau = fma(w, -0.5f, 1.0f);
	for(uint q=0u; q<Q; q++) Fin[q] *= c_tau;
#endif
#ifndef EQUILIBRIUM_BOUNDARIES
    for(uint q=0u; q<Q; q++) fhn[q] = fma(1.0f-w, fhn[q], fma(w, feq[q], Fin[q])); // perform collision (SRT)
#else
	for(uint q=0u; q<Q; q++) fhn[q] = flagsn_bo==TYPE_E ? feq[q] : fma(1.0f-w, fhn[q], fma(w, feq[q], Fin[q])); // perform collision (SRT)
#endif
#elif defined(TRT)
	const float wp = w; // TRT: inverse of "+" relaxation time
	const float wm = 1.0f/(0.1875f/(1.0f/w-0.5f)+0.5f); // TRT: inverse of "-" relaxation time wm = 1.0f/(0.1875f/(3.0f*nu)+0.5f), nu = (1.0f/w-0.5f)/3.0f;
#ifdef VOLUME_FORCE
	const float c_taup=fma(wp, -0.25f, 0.5f), c_taum=fma(wm, -0.25f, 0.5f); // source: https://arxiv.org/pdf/1901.08766.pdf
	float Fib[Q]; // F_bar
	Fib[0] = Fin[0];
	for(uint q=1u; q<Q; q+=2u) {
		Fib[q   ] = Fin[q+1u];
		Fib[q+1u] = Fin[q   ];
	}
	for(uint q=0u; q<Q; q++) Fin[q] = fma(c_taup, Fin[q]+Fib[q], c_taum*(Fin[q]-Fib[q]));
#endif
	float fhb[Q]; // fhn in inverse directions
	float feb[Q]; // feq in inverse directions
	fhb[0] = fhn[0];
	feb[0] = feq[0];
	for(uint q=1u; q<Q; q+=2u) {
		fhb[q   ] = fhn[q+1u];
		fhb[q+1u] = fhn[q   ];
		feb[q   ] = feq[q+1u];
		feb[q+1u] = feq[q   ];
	}
#ifndef EQUILIBRIUM_BOUNDARIES
	for(uint q=0u; q<Q; q++) fhn[q] = fma(0.5f*wp, feq[q]-fhn[q]+feb[q]-fhb[q], fma(0.5f*wm, feq[q]-feb[q]-fhn[q]+fhb[q], fhn[q]+Fin[q])); // perform collision (TRT)
#else // EQUILIBRIUM_BOUNDARIES
	for(uint q=0u; q<Q; q++) fhn[q] = flagsn_bo==TYPE_E ? feq[q] : fma(0.5f*wp, feq[q]-fhn[q]+feb[q]-fhb[q], fma(0.5f*wm, feq[q]-feb[q]-fhn[q]+fhb[q], fhn[q]+Fin[q])); // perform collision (TRT)
#endif // EQUILIBRIUM_BOUNDARIES
#endif // TRT

    store_f(index, fhn, nbs, ubo.t); // perform streaming (part 1)
}