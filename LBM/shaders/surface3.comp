#version 450
#extension GL_ARB_shading_language_include : require
#include "simulation_header.glsl"

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// apply flag changes and calculate excess mass
void main()
{
    uvec3 globalSize = gl_NumWorkGroups * gl_WorkGroupSize;
    uint index = gl_GlobalInvocationID.z * globalSize.x * globalSize.y + gl_GlobalInvocationID.y * globalSize.x + gl_GlobalInvocationID.x;
    if (index >= ubo.Nxyz) return;
    
	const uint flagsn_sus = flags[index]&(TYPE_SU|TYPE_S); // extract SURFACE flags
	if((flagsn_sus&TYPE_S)!=0) return;
	//const float rhon = rhos[index]; // density of cell n
	const float rhon = states[index].w; // density of cell n
	float massn = masses[index]; // mass of cell n
	float massexn = 0.0f; // excess mass of cell n
	float phin = 0.0f;
	if(flagsn_sus==TYPE_F) { // regular fluid cell
		massexn = massn-rhon; // dump mass-rho difference into excess mass
		massn = rhon; // fluid cell mass has to equal rho
		phin = 1.0f;
	} else if(flagsn_sus==TYPE_I) { // regular interface cell
		massexn = massn>rhon ? massn-rhon : massn<0.0f ? massn : 0.0f; // allow interface cells with mass>rho or mass<0
		massn = clamp(massn, 0.0f, rhon);
		phin = calculate_phi(rhon, massn, TYPE_I); // calculate fill level for next step (only necessary for interface cells)
	} else if(flagsn_sus==TYPE_G) { // regular gas cell
		massexn = massn; // dump remaining mass into excess mass
		massn = 0.0f;
		phin = 0.0f;
	} else if(flagsn_sus==TYPE_IF) { // flag interface->fluid is set
		flags[index] = (flags[index]&~TYPE_SU)|TYPE_F; // cell becomes fluid
		massexn = massn-rhon; // dump mass-rho difference into excess mass
		massn = rhon; // fluid cell mass has to equal rho
		phin = 1.0f; // set phi[n] to 1.0f for fluid cells
	} else if(flagsn_sus==TYPE_IG) { // flag interface->gas is set
		flags[index] = (flags[index]&~TYPE_SU)|TYPE_G; // cell becomes gas
		massexn = massn; // dump remaining mass into excess mass
		massn = 0.0f; // gas mass has to be zero
		phin = 0.0f; // set phi[n] to 0.0f for gas cells
	} else if(flagsn_sus==TYPE_GI) { // flag gas->interface is set
		flags[index] = (flags[index]&~TYPE_SU)|TYPE_I; // cell becomes interface
		massexn = massn>rhon ? massn-rhon : massn<0.0f ? massn : 0.0f; // allow interface cells with mass>rho or mass<0
		massn = clamp(massn, 0.0f, rhon);
		phin = calculate_phi(rhon, massn, TYPE_I); // calculate fill level for next step (only necessary for interface cells)
	}
	uint nbs[Q]; // neighbor indices
	neighbors(index, nbs); // calculate neighbor indices
	uint counter = 0u; // count (fluid|interface) neighbors
	for(uint q=1u; q<Q; q++) { // simple model: distribute excess mass equally to all interface and fluid neighbors
		const uint flagsji_su = flags[nbs[q]]&(TYPE_SU|TYPE_S); // extract SURFACE flags
		counter += uint(flagsji_su==TYPE_F||flagsji_su==TYPE_I||flagsji_su==TYPE_IF||flagsji_su==TYPE_GI); // avoid branching
	}
	massn += counter>0u ? 0.0f : massexn; // if excess mass can't be distributed to neighboring interface or fluid cells, add it to local mass (ensure mass conservation)
	massexn = counter>0u ? massexn/float(counter) : 0.0f; // divide excess mass up for all interface or fluid neighbors
	masses[index] = massn * (totalMass[1] / totalMass[0]); // update mass
	massexes[index] = massexn; // update excess mass
	phis[index] = phin; // update phi
}
// possible types at the end of surface_3(): TYPE_F / TYPE_I / TYPE_G